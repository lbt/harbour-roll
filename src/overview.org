harbour-roll

main, initialises QML object "Roll"


* roll : a GLItem : a QQuickItem

handles user input from QML

very app specific

prep() is where GL one-time setup is done

Calls bullet.setupGL(m_program_dice);

BAD:
  m_runner setup
  bullet restore state
  create GL_ARRAY_BUFFER
  setRunning()

render() is where the GL rendering is done

BAD:
camera update (move camera to world)
light position update (move lights to world)
bind program (move to world-render and let it control that)
setup lighting uniforms (ditto, world-render can optimise order of programs)
debug render (ditto)

* glitem

allows rendering of GL via prep()/render() in the paint() call


*






New

http://bulletphysics.org/mediawiki-1.5.8/index.php/Canonical_Game_Loop

Create QML and splash

Create world and runner

Connect world and runner to QML : in GLitem.prep()

Setup GL for world items : in GLitem.prep()

Render world during refresh : in GLitem.render()

Pass UI to world at end of refresh using queue

Start world runner


* AssetStore
Things are keyed by name and typically a named vao/collisionshape
will be used together.

Creates/contains:
  * VAO
  * Texture
  * shader
  * renderables
  * btCollisionShapes
  * curves


* Renderable
  Something that appears onscreen
  * shaders (GLPrograms)
  * Asset/VAO
  * Asset/Texture
methods:
  + render()

* WorldBuilder
  reads a scene, aiMeshes, json etc
 1) reads data into AsssetStore from obj and json
 2) creates objects, adds to world

* World
WorldItems add themselves to a world.

 * physicsWorld
 * WorldItem
 * physicsThread
 * Containers

methods
 + render()
   renders world objects by shader groups
 + step()

* WorldItem
  World objects

contains:
 * geometry
 * physics
 * 0+ renderable (invisible objects etc)
 * world

methods
 + register()
   in the world ??
 + render()

* Physics
simple wrapper around a btRigidBody


* Light

* Camera



* Shaders



* Game objects : World objects + sig/slots


* Paths
 Mesh



